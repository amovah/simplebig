package simplebig

import (
	"database/sql/driver"
	"fmt"
)

// Append appends to buf the string form of the floating-point number x,
// as generated by x.Text, and returns the extended buffer.
func (x Float) Append(buf []byte, fmt byte, prec int) []byte {
	return x.bigFloat.Append(buf, fmt, prec)
}

// String formats x like x.Text('g', 10).
func (x *Float) String() string {
	return x.bigFloat.String()
}

// Format implements fmt.Formatter. It accepts all the regular
// formats for floating-point numbers ('b', 'e', 'E', 'f', 'F',
// 'g', 'G', 'x') as well as 'p' and 'v'. See (*Float).Text for the
// interpretation of 'p'. The 'v' format is handled like 'g'.
// Format also supports specification of the minimum precision
// in digits, the output field width, as well as the format flags
// '+' and ' ' for sign control, '0' for space or zero padding,
// and '-' for left or right justification. See the fmt package
// for details.
func (x *Float) Format(s fmt.State, format rune) {
	x.bigFloat.Format(s, format)
}

// GobDecode implements the gob.GobDecoder interface.
// The result is rounded per the precision and rounding mode of
// z unless z's precision is 0, in which case z is set exactly
// to the decoded value.
func (x *Float) GobDecode(buf []byte) error {
	return x.bigFloat.GobDecode(buf)
}

// GobEncode implements the gob.GobEncoder interface.
// The Float value and all its attributes (precision,
// rounding mode, accuracy) are marshaled.
func (x *Float) GobEncode() ([]byte, error) {
	return x.bigFloat.GobEncode()

}

// MarshalText implements the encoding.TextMarshaler interface.
// Only the Float value is marshaled (in full precision), other
// attributes such as precision or accuracy are ignored.
func (x *Float) MarshalText() ([]byte, error) {
	return x.bigFloat.MarshalText()
}

// Parse parses s which must contain a text representation of a floating-
// point number with a mantissa in the given conversion base (the exponent
// is always a decimal number), or a string representing an infinite value.
// check math/big.Float.Parse for more inforamtions.
func (x Float) Parse(s string, base int) (Float, int, error) {
	parsed, b, err := x.bigFloat.Parse(s, base)
	return Float{
		bigFloat: parsed,
	}, b, err
}

// Scan implements sql.Scanner interface.
func (x *Float) Scan(dbValue interface{}) error {
	switch src := dbValue.(type) {
	case nil:
		return nil
	case string:
		if src == "" {
			return nil
		}

		stringValue, ok := dbValue.(string)
		if !ok {
			return fmt.Errorf("Scan: unable to cast type %T into string in BigNumber", src)
		}

		_, ok = x.SetString(stringValue)
		if !ok {
			return fmt.Errorf("Scan: unable to set string to big.int in BigNumber, source: %s", src)
		}

		return nil
	default:
		return fmt.Errorf("Scan: unable to scan type %T into BigNumber", src)
	}
}

// Value implements sql/driver.Valuer interface.
func (x Float) Value() (driver.Value, error) {
	return x.String(), nil
}
